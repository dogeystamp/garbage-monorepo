<!DOCTYPE html>
<html>
	<head>
		<title>Pong wars | Koen van Gilst</title>
		<link rel="canonical" href="https://pong-wars.koenvangilst.nl/" />
		<style>
			html {
				height: 100%;
			}

			body {
				height: 100%;
				margin: 0;
				padding: 0;
				display: flex;
				justify-content: center;
				align-items: center;
				background: linear-gradient(to bottom, #172b36 0%, #d9e8e3 100%);
			}

			#container {
				display: flex;
				width: 100%;
				max-width: 1000px;
				align-items: center;
				flex-direction: column;
				height: 100%;
			}

			#pongCanvas {
				display: block;
				border-radius: 4px;
				overflow: hidden;
				width: 100%;
				margin-top: auto;
				box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
			}

			#score {
				font-family: monospace;
				margin-top: 30px;
				font-size: 20px;
				padding-left: 20px;
				color: #172b36;
			}

			#made {
				font-family: monospace;
				margin-top: auto;
				margin-bottom: 20px;
				font-size: 12px;
				padding-left: 20px;
			}

			#instr {
				font-family: monospace;
				font-size: 12px;
				padding-left: 20px;
			}

			#made a {
				color: #172b36;
			}
		</style>
	</head>

	<body>
		<div id="container">
			<canvas id="pongCanvas" width="1200" height="800"></canvas>
			<div id="score"></div>
			<p id="instr">
			balls can be controlled with number keys
			</p>
			<p id="made">
				made by <a href="https://koenvangilst.nl">Koen van Gilst</a> | source on
				<a href="https://github.com/vnglst/pong-wars">github</a>
				<br>
				patches from dogeystamp | patched source on
				<a href="https://github.com/dogeystamp/garbage-monorepo/tree/main/pongwars">github</a>
			</p>
		</div>
	</body>

	<script>
		// Based on: https://github.com/vnglst/pong-wars
		// Idea for Pong wars: https://twitter.com/nicolasdnl/status/1749715070928433161

		// This code is patched: see https://github.com/dogeystamp/garbage-monorepo/tree/main/pongwars
		// Main features added are controlling balls and colors being able to die

		const canvas = document.getElementById("pongCanvas");
		const ctx = canvas.getContext("2d");
		const scoreElement = document.getElementById("score");

		var suddenDeathStart = null;
		var suddenDeathCoeff = 0;

		const teams = [
			{
				name: "red",
				color: "indianred",
				backgroundColor: "darkred",
				x: 256,
				y: 256,
				dx: 8,
				dy: 8,
				score: 0,
			},
			{
				name: "blue",
				color: "blue",
				backgroundColor: "darkblue",
				x: 768,
				y: 256,
				dx: -8,
				dy: 8,
				score: 0,
			},
			{
				name: "green",
				color: "green",
				backgroundColor: "darkgreen",
				x: 256,
				y: 768,
				dx: 8,
				dy: -8,
				score: 0,
			},
			{
				name: "orange",
				color: "coral",
				backgroundColor: "chocolate",
				x: 768,
				y: 768,
				dx: -8,
				dy: -8,
				score: 0,
			},
			{
				name: "white",
				color: "white",
				backgroundColor: "gainsboro",
				x: 400,
				y: 768,
				dx: -9,
				dy: -9,
				score: 0,
			},
			{
				name: "black",
				color: "#333333",
				backgroundColor: "black",
				x: 400,
				y: 300,
				dx: -8,
				dy: -8,
				score: 0,
			},
			{
				name: "ourple",
				color: "violet",
				backgroundColor: "purple",
				x: 400,
				y: 768,
				dx: -8,
				dy: -8,
				score: 0,
			},
			{
				name: "gray",
				color: "gray",
				backgroundColor: "#333333",
				x: 400,
				y: 768,
				dx: -8,
				dy: -8,
				score: 0,
			},
		];

	var state = teams.map((team) => ({
		elim: false,
		boostEnabled: false,
	}))

		const squareSize = 16;
		const numSquaresX = canvas.width / squareSize;
		const numSquaresY = canvas.height / squareSize;
		let squares = [];

	document.addEventListener("keydown", (event) => {
		const key = parseInt(event.key)
		if (isNaN(key)) return
		state[key].boostEnabled = true;
	})
	document.addEventListener("keyup", (event) => {
		const key = parseInt(event.key)
		if (isNaN(key)) return
		state[key].boostEnabled = false;
	})

		for (let i = 0; i < numSquaresX; i++) {
			squares[i] = [];
			for (let j = 0; j < numSquaresY; j++) {
				const t = randInt(0, teams.length-1);
				squares[i][j] = t;
			}
		}

		function randomNum(min, max) {
			return Math.random() * (max - min) + min;
		}

	function randInt(min, max) {
		return Math.floor(randomNum(min, max+1))
	}

	function elapsedSec() {
		return ((new Date()) - suddenDeathStart)/1000
	}

		updateScoreElement();

		function drawBall(x, y, color) {
			ctx.beginPath();
			ctx.arc(x, y, squareSize / 2, 0, Math.PI * 2, false);
			ctx.fillStyle = color;
			ctx.fill();
			ctx.closePath();
		}

		function drawSquares() {
			for (let i = 0; i < numSquaresX; i++) {
				for (let j = 0; j < numSquaresY; j++) {
					ctx.fillStyle = teams[squares[i][j]].backgroundColor;
					ctx.fillRect(i * squareSize, j * squareSize, squareSize, squareSize);
				}
			}
		}

	function clamp(min, max, num) {
		return Math.min(max, Math.max(min, num))
	}

	function mix(x, y, v) {
		return v*x + (1-v)*y;
	}

	var nTeams = teams.length;

	function updateSquareAndBounce(x, y, dx, dy, color) {
		if (state[color].elim) return
		if (Math.max(Math.abs(dx), Math.abs(dy)) < 0.02) state[color].elim = true

		nTeams = state.map(t => !t.elim).filter(Boolean).length

		if (Math.min(x, y) < 0 || isNaN(x) || isNaN(y)) {
			console.warn(`warped ${teams[color].name}`)
			teams[color].x = canvas.width * 0.1;
			teams[color].y = canvas.height * 0.1;
			dx = 4;
			dy = 4;
		}

		if (x > canvas.width || y > canvas.height) {
			console.warn(`warped ${teams[color].name}`)
			teams[color].x = canvas.width * 0.9;
			teams[color].y = canvas.height * 0.9;
			dx = -4;
			dy = -4;
		}

		// death coefficient (if not enough territory, slow down)
		const coeff = Math.min((teams[color].score/(numSquaresX*numSquaresY/nTeams/mix(1.2, 4, suddenDeathCoeff))), 1.00);

		// death coefficient when no collision
		const vacuumCoeff = coeff**(0.01);

		let updatedDx = dx * vacuumCoeff;
		let updatedDy = dy * vacuumCoeff;

		// Check multiple points around the ball's circumference
		for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
			let checkX = x + Math.cos(angle) * (squareSize / 2);
			let checkY = y + Math.sin(angle) * (squareSize / 2);

			let i = Math.floor(checkX / squareSize);
			let j = Math.floor(checkY / squareSize);

			if (i >= 0 && i < numSquaresX && j >= 0 && j < numSquaresY) {
				if (squares[i][j] !== color) {
					const foreign = squares[i][j];
					if (state[foreign].elim) {
						console.log(`${teams[color].name} claims the remaining territory of ${teams[foreign].name}`)
						for (let ai = 0; ai < numSquaresX; ai++) {
							for (let aj = 0; aj < numSquaresY; aj++) {
								if (squares[ai][aj] == foreign) squares[ai][aj] = color;
							}
						}
					}

					squares[i][j] = color;

					// Determine bounce direction based on the angle
					if (Math.abs(Math.cos(angle)) > Math.abs(Math.sin(angle))) {
						updatedDx = -updatedDx;
					} else {
						updatedDy = -updatedDy;
					}

					updatedDx += randomNum(-0.15, mix(0.153, 0.15, suddenDeathCoeff));
					updatedDy += randomNum(-0.15, 0.15);
					updatedDx *= coeff;
					updatedDy *= coeff;
					const speedLim = mix(30, 13, suddenDeathCoeff)
					const norm = (updatedDx**2 + updatedDy**2)**(1/2)
					const scalar = Math.min(speedLim/norm, 1)
					updatedDx *= scalar;
					updatedDy *= scalar;

				}
			}
		}

		const theta = (Math.PI/180)*10;
		const ct = Math.cos(theta);
		const st = Math.sin(theta);
		if (state[color].boostEnabled) {
			const rotDx = (ct * updatedDx - st * updatedDy);
			const rotDy = (st * updatedDx + ct * updatedDy);
			updatedDx = rotDx;
			updatedDy = rotDy;
		}

		return { dx: updatedDx, dy: updatedDy };
	}

	function updateScoreElement() {
		if (!squares) {
			return;
		}
		teams.forEach((t) => (t.score = 0));
		for (let i = 0; i < numSquaresX; i++) {
			for (let j = 0; j < numSquaresY; j++) {
				teams[squares[i][j]].score++;
			}
		}
		for (let i = 0; i < teams.length; i++) {
			if (teams[i].score <= 4) {
				state[i].elim = true
			}
		}

		if (nTeams > 1) {
			scoreElement.textContent = teams
				.map((t, idx) => `(${idx}) ${t.name} ${t.score}`)
				.filter((t, idx) => !state[idx].elim)
			.join(" | ") + (suddenDeathCoeff > 0.1 ? " | sudden death!" : "");
		} else {
			scoreElement.textContent = teams
				.filter((t, idx) => !state[idx].elim)
				.map((t) => `${t.name} ðŸ‘‘ wins`)
		}
	}

	function draw() {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		drawSquares();

		for (let i = 0; i < teams.length; i++) {
		if (state[i].elim) continue
			const t = teams[i];
			drawBall(t.x, t.y, t.color);
			let bounce = updateSquareAndBounce(t.x, t.y, t.dx, t.dy, i);
			t.dx = bounce.dx;
			t.dy = bounce.dy;

			if (
				t.x + t.dx > canvas.width - squareSize / 2 ||
				t.x + t.dx < squareSize / 2
			) {
				t.dx = -t.dx;
			}
			if (
				t.y + t.dy > canvas.height - squareSize / 2 ||
				t.y + t.dy < squareSize / 2
			) {
				t.dy = -t.dy;
			}

			t.x += t.dx;
			t.y += t.dy;
		}

		updateScoreElement();
		if (suddenDeathStart !== null) {
			suddenDeathCoeff = Math.min((elapsedSec()/60/5)**15, 1);
		} else if (nTeams <= 3) {
			suddenDeathStart = new Date();
		}
		requestAnimationFrame(draw);
	}

	requestAnimationFrame(draw);
	</script>
</html>
